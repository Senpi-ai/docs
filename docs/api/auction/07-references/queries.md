---
id: queries
title: Queries
slug: queries
sidebar_position: 1
---

<!-- Do not edit this file, it has been automatically generated by docusaurus-graphql-plugin -->

## \_meta

**Type:** [\_Meta\_](objects#_meta_)

Access to subgraph metadata

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>

</td>
</tr>
</tbody>
</table>

## auctionCleared

**Type:** [AuctionCleared](objects#auctioncleared)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## auctionCleareds

**Type:** [[AuctionCleared!]!](objects#auctioncleared)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#auctioncleared_orderby"><code>AuctionCleared_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#auctioncleared_filter"><code>AuctionCleared_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## auctionDetail

**Type:** [AuctionDetail](objects#auctiondetail)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## auctionDetails

**Type:** [[AuctionDetail!]!](objects#auctiondetail)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#auctiondetail_orderby"><code>AuctionDetail_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#auctiondetail_filter"><code>AuctionDetail_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## blockInfo

**Type:** [BlockInfo](objects#blockinfo)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## blockInfos

**Type:** [[BlockInfo!]!](objects#blockinfo)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#blockinfo_orderby"><code>BlockInfo_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#blockinfo_filter"><code>BlockInfo_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## cancellationSellOrder

**Type:** [CancellationSellOrder](objects#cancellationsellorder)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## cancellationSellOrders

**Type:** [[CancellationSellOrder!]!](objects#cancellationsellorder)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#cancellationsellorder_orderby"><code>CancellationSellOrder_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#cancellationsellorder_filter"><code>CancellationSellOrder_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## claimedFromOrder

**Type:** [ClaimedFromOrder](objects#claimedfromorder)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## claimedFromOrders

**Type:** [[ClaimedFromOrder!]!](objects#claimedfromorder)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#claimedfromorder_orderby"><code>ClaimedFromOrder_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#claimedfromorder_filter"><code>ClaimedFromOrder_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## newAuction

**Type:** [NewAuction](objects#newauction)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## newAuctions

**Type:** [[NewAuction!]!](objects#newauction)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#newauction_orderby"><code>NewAuction_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#newauction_filter"><code>NewAuction_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## newSellOrder

**Type:** [NewSellOrder](objects#newsellorder)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## newSellOrders

**Type:** [[NewSellOrder!]!](objects#newsellorder)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#newsellorder_orderby"><code>NewSellOrder_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#newsellorder_filter"><code>NewSellOrder_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## newUser

**Type:** [NewUser](objects#newuser)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## newUsers

**Type:** [[NewUser!]!](objects#newuser)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#newuser_orderby"><code>NewUser_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#newuser_filter"><code>NewUser_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## order

**Type:** [Order](objects#order)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## orderCounter

**Type:** [OrderCounter](objects#ordercounter)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## orderCounters

**Type:** [[OrderCounter!]!](objects#ordercounter)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#ordercounter_orderby"><code>OrderCounter_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#ordercounter_filter"><code>OrderCounter_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## orders

**Type:** [[Order!]!](objects#order)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#order_orderby"><code>Order_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#order_filter"><code>Order_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## orderTxn

**Type:** [OrderTxn](objects#ordertxn)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## orderTxns

**Type:** [[OrderTxn!]!](objects#ordertxn)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#ordertxn_orderby"><code>OrderTxn_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#ordertxn_filter"><code>OrderTxn_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## ownershipTransferred

**Type:** [OwnershipTransferred](objects#ownershiptransferred)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## ownershipTransferreds

**Type:** [[OwnershipTransferred!]!](objects#ownershiptransferred)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#ownershiptransferred_orderby"><code>OwnershipTransferred_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#ownershiptransferred_filter"><code>OwnershipTransferred_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## summaries

**Type:** [[Summary!]!](objects#summary)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#summary_orderby"><code>Summary_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#summary_filter"><code>Summary_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## summary

**Type:** [Summary](objects#summary)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## token

**Type:** [Token](objects#token)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## tokens

**Type:** [[Token!]!](objects#token)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#token_orderby"><code>Token_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#token_filter"><code>Token_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## user

**Type:** [User](objects#user)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## userRegistration

**Type:** [UserRegistration](objects#userregistration)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## userRegistrations

**Type:** [[UserRegistration!]!](objects#userregistration)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#userregistration_orderby"><code>UserRegistration_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#userregistration_filter"><code>UserRegistration_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## users

**Type:** [[User!]!](objects#user)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#user_orderby"><code>User_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#user_filter"><code>User_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>
