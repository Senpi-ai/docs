---
id: queries
title: Queries
slug: queries
sidebar_position: 1
---

<!-- Do not edit this file, it has been automatically generated by docusaurus-graphql-plugin -->

## \_meta

**Type:** [\_Meta\_](objects#_meta_)

`_meta` will return you the protocol subgraph metadata.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>

</td>
</tr>
</tbody>
</table>

## auction

**Type:** [Auction](objects#auction)

`auction` enables you to fetch on-chain data about a certain [auction](../../../learn/glossary.mdx#fan-token-auctions) on the Moxie protocol.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## auctions

**Type:** [[Auction!]!](objects#auction)

`auctions` enables you to fetch on-chain data about all [auctions](../../../learn/glossary.mdx#fan-token-auctions) on the Moxie protocol with filters available to fetch auctions that fulfill certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#auction_orderby"><code>Auction_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#auction_filter"><code>Auction_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## auctionUser

**Type:** [AuctionUser](objects#auctionuser)

`auctionUser` enables you to fetch a certain user that has registered for [auction](../../../learn/glossary.mdx#fan-token-auctions) on the Moxie protocol.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## auctionUsers

`auctionUsers` enables you to fetch all users that have registered for [auction](../../../learn/glossary.mdx#fan-token-auctions) on the Moxie protocol with filters available to fetch users that fulfill certain requirements.

**Type:** [[AuctionUser!]!](objects#auctionuser)

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#auctionuser_orderby"><code>AuctionUser_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#auctionuser_filter"><code>AuctionUser_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## blockInfo

**Type:** [BlockInfo](objects#blockinfo)

`blockInfo` enables you to fetch on-chain data related to a certain block.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## blockInfos

**Type:** [[BlockInfo!]!](objects#blockinfo)

`blockInfos` enables you to fetch on-chain data related to blocks indexed by the subgraph, that is when certain events from the Moxie protocol occurs.

This is most useful when you include it in the response field when calling other APIs.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#blockinfo_orderby"><code>BlockInfo_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#blockinfo_filter"><code>BlockInfo_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## order

**Type:** [Order](objects#order)

`order` allows you to fetch a certain [buy](../../../learn/glossary.mdx#buy-orders) and [sell order](../../../learn/glossary.mdx#sell-orders) that occurs in the Moxie protocol.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## orders

**Type:** [[Order!]!](objects#order)

`order` provides you with all the [buy](../../../learn/glossary.mdx#buy-orders) and [sell orders](../../../learn/glossary.mdx#sell-orders) occurs in the Moxie protocol.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#order_orderby"><code>Order_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#order_filter"><code>Order_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## portfolio

**Type:** [Portfolio](objects#portfolio)

`portfolio` allows you to fetch the user's balance of a certain fan token, by providing the `id` input with `${user-address}-${token-address}` format.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>
<p>portfolio ID, formatted as `${user-address}-${token-address}`</p>
</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## portfolios

**Type:** [[Portfolio!]!](objects#portfolio)

`portfolios` indexes with the [subject token](../../../learn/glossary.mdx#subject-token) holdings of a certain user or list of holders of certain [subject tokens](../../../learn/glossary.mdx#subject-token).

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#portfolio_orderby"><code>Portfolio_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#portfolio_filter"><code>Portfolio_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## protocolFeeBeneficiaries

**Type:** [[ProtocolFeeBeneficiary!]!](objects#protocolfeebeneficiary)

`protocolFeeBeneficiaries` indexes the address and details of the beneficiary that receives the protocol fees.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#protocolfeebeneficiary_orderby"><code>ProtocolFeeBeneficiary_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#protocolfeebeneficiary_filter"><code>ProtocolFeeBeneficiary_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## protocolFeeBeneficiary

**Type:** [ProtocolFeeBeneficiary](objects#protocolfeebeneficiary)

`protocolFeeBeneficiary` indexes the address and details of the beneficiary that receives the protocol fees.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## protocolFeeTransfer

**Type:** [ProtocolFeeTransfer](objects#protocolfeetransfer)

`protocolFeeTransfer` tracks and indexes all the protocol fee transfers that occur on the Moxie protocol. This API will return you a certain protocol fee transfer that you specify.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## protocolFeeTransfers

**Type:** [[ProtocolFeeTransfer!]!](objects#protocolfeetransfer)

`protocolFeeTransfers` tracks and indexes all the protocol fee transfers that occur on the Moxie protocol. This API will return you all the protocol fee transfers that occur on the protocol and you can add more filters to fetch certain transfers that fulfill the specified requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#protocolfeetransfer_orderby"><code>ProtocolFeeTransfer_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#protocolfeetransfer_filter"><code>ProtocolFeeTransfer_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectFeeTransfer

**Type:** [SubjectFeeTransfer](objects#subjectfeetransfer)

`subjectFeeTransfer` tracks and indexes all the subject fee transfers that occur on the Moxie protocol. This API will return you a certain subject fee transfer.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectFeeTransfers

**Type:** [[SubjectFeeTransfer!]!](objects#subjectfeetransfer)

`subjectFeeTransfers` tracks and indexes all the subject fee transfers that occur on the Moxie protocol. This API will return you all the subject fee transfers that occur on the protocol and you can add more filters to fetch certain transfers that fulfill the specified requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#subjectfeetransfer_orderby"><code>SubjectFeeTransfer_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#subjectfeetransfer_filter"><code>SubjectFeeTransfer_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectToken

**Type:** [SubjectToken](objects#subjecttoken)

`subjectToken` indexes all the [subject tokens](../../../learn/glossary.mdx#subject-token) that was created on the Moxie protocol. This API helps you to fetch a certain [subject token](../../../learn/glossary.mdx#subject-token).

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokenDailySnapshot

**Type:** [SubjectTokenDailySnapshot](objects#subjecttokendailysnapshot)

`subjectTokenDailySnapshot` indexes the daily snapshot information details of all [subject tokens](../../../learn/glossary.mdx#subject-token) on the Moxie protocol. This API can help you to get a certain snapshot.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokenDailySnapshots

**Type:** [[SubjectTokenDailySnapshot!]!](objects#subjecttokendailysnapshot)

`subjectTokenDailySnapshots` indexes the daily snapshot information details of all [subject tokens](../../../learn/glossary.mdx#subject-token) on the Moxie protocol. This API can help you to get all snapshots and filter them based on certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#subjecttokendailysnapshot_orderby"><code>SubjectTokenDailySnapshot_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#subjecttokendailysnapshot_filter"><code>SubjectTokenDailySnapshot_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokenHourlySnapshot

**Type:** [SubjectTokenHourlySnapshot](objects#subjecttokenhourlysnapshot)

`subjectTokenHourlySnapshot` indexes the hourly snapshot information details of all [subject tokens](../../../learn/glossary.mdx#subject-token) on the Moxie protocol. This API can help you to get a certain snapshot.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokenHourlySnapshots

**Type:** [[SubjectTokenHourlySnapshot!]!](objects#subjecttokenhourlysnapshot)

`subjectTokenHourlySnapshots` indexes the hourly snapshot information details of all [subject tokens](../../../learn/glossary.mdx#subject-token) on the Moxie protocol. This API can help you to get all snapshots and filter them based on certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#subjecttokenhourlysnapshot_orderby"><code>SubjectTokenHourlySnapshot_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#subjecttokenhourlysnapshot_filter"><code>SubjectTokenHourlySnapshot_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokenRollingDailySnapshot

**Type:** [SubjectTokenRollingDailySnapshot](objects#subjecttokenrollingdailysnapshot)

`subjectTokenRollingDailySnapshot` indexes the rolling daily snapshot information details of all [subject tokens](../../../learn/glossary.mdx#subject-token) on the Moxie protocol. This API can help you to get a certain snapshot.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokenRollingDailySnapshots

**Type:** [[SubjectTokenRollingDailySnapshot!]!](objects#subjecttokenrollingdailysnapshot)

`subjectTokenRollingDailySnapshots` indexes the rolling daily snapshot information details of all [subject tokens](../../../learn/glossary.mdx#subject-token) on the Moxie protocol. This API can help you to get all snapshots and filter them based on certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#subjecttokenrollingdailysnapshot_orderby"><code>SubjectTokenRollingDailySnapshot_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#subjecttokenrollingdailysnapshot_filter"><code>SubjectTokenRollingDailySnapshot_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokens

**Type:** [[SubjectToken!]!](objects#subjecttoken)

`subjectTokens` indexes all the [subject tokens](../../../learn/glossary.mdx#subject-token) that was created on the Moxie protocol. This API helps you to fetch all [subject tokens](../../../learn/glossary.mdx#subject-token) and can filter by adding certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#subjecttoken_orderby"><code>SubjectToken_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#subjecttoken_filter"><code>SubjectToken_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## summaries

**Type:** [[Summary!]!](objects#summary)

`summaries` will return you the Moxie protocol summary information.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#summary_orderby"><code>Summary_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#summary_filter"><code>Summary_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## summary

**Type:** [Summary](objects#summary)

`summaries` will return you the Moxie protocol summary information.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## user

**Type:** [User](objects#user)

`user` indexes all users on the Moxie protocol. This API can help you get a certain user's related information, such as [buy](../../../learn/glossary.mdx#buy-orders)/[sell orders](../../../learn/glossary.mdx#sell-orders), fan token [portfolio](../../../learn/glossary.mdx#portfolio), etc.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## users

**Type:** [[User!]!](objects#user)

`users` indexes all users on the Moxie protocol. This API can help you get all Moxie users' related information, such as [buy](../../../learn/glossary.mdx#buy-orders)/[sell orders](../../../learn/glossary.mdx#sell-orders), fan token [portfolio](../../../learn/glossary.mdx#portfolio), etc.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#user_orderby"><code>User_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#user_filter"><code>User_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>
