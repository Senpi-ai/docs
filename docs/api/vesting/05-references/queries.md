---
id: queries
title: Queries
slug: queries
sidebar_position: 1
---

<!-- Do not edit this file, it has been automatically generated by docusaurus-graphql-plugin -->

## \_meta

**Type:** [\_Meta\_](objects#_meta_)

`_meta` will return you the protocol subgraph metadata.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>

</td>
</tr>
</tbody>
</table>

## authorizedFunction

**Type:** [AuthorizedFunction](objects#authorizedfunction)

`authorizedFunction` indexes all authorized functions available for the token manager. This API will allow you to fetch a certain authorized function.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## authorizedFunctions

**Type:** [[AuthorizedFunction!]!](objects#authorizedfunction)

`authorizedFunctions` indexes all authorized functions available for the token manager. This API will allow you to fetch all authorized functions and filter based on certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#authorizedfunction_orderby"><code>AuthorizedFunction_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#authorizedfunction_filter"><code>AuthorizedFunction_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectToken

**Type:** [SubjectToken](objects#subjecttoken)

`subjectToken` indexes all [subject tokens](../../../learn/glossary.mdx#subject-token) that have interacted with the vesting contract. This API will allow you to fetch a certain [subject token](../../../learn/glossary.mdx#subject-token).

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## subjectTokens

**Type:** [[SubjectToken!]!](objects#subjecttoken)

`subjectToken` indexes all [subject tokens](../../../learn/glossary.mdx#subject-token) that have interacted with the vesting contract. This API will allow you to fetch all [subject tokens](../../../learn/glossary.mdx#subject-token) and filter based on certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#subjecttoken_orderby"><code>SubjectToken_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#subjecttoken_filter"><code>SubjectToken_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## tokenLockManager

**Type:** [TokenLockManager](objects#tokenlockmanager)

`tokenLockManager` indexes the token lock manager of the vesting contract. This API will return details about the token lock manager.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## tokenLockManagers

**Type:** [[TokenLockManager!]!](objects#tokenlockmanager)

`tokenLockManagers` indexes the token lock manager of the vesting contract. This API will return details about the token lock manager.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#tokenlockmanager_orderby"><code>TokenLockManager_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#tokenlockmanager_filter"><code>TokenLockManager_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## tokenLockWallet

**Type:** [TokenLockWallet](objects#tokenlockwallet)

`tokenLockWallet` indexes all beneficiary wallet addresses of the vesting contract. This API will allow you to fetch a certain beneficiary.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
id<br />
<a href="scalars#id"><code>ID!</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>

## tokenLockWallets

**Type:** [[TokenLockWallet!]!](objects#tokenlockwallet)

`tokenLockWallet` indexes all beneficiary wallet addresses of the vesting contract. This API will allow you to fetch all beneficiaries and filter based on certain requirements.

<p style={{ marginBottom: "0.4em" }}><strong>Arguments</strong></p>

<table>
<thead><tr><th>Name</th><th>Description</th></tr></thead>
<tbody>
<tr>
<td>
skip<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
first<br />
<a href="scalars#int"><code>Int</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderBy<br />
<a href="enums#tokenlockwallet_orderby"><code>TokenLockWallet_orderBy</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
orderDirection<br />
<a href="enums#orderdirection"><code>OrderDirection</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
where<br />
<a href="inputObjects#tokenlockwallet_filter"><code>TokenLockWallet_filter</code></a>
</td>
<td>

</td>
</tr>
<tr>
<td>
block<br />
<a href="inputObjects#block_height"><code>Block_height</code></a>
</td>
<td>
<p>The block at which the query should be executed. Can either be a <code>&#123; hash: Bytes &#125;</code> value containing a block hash, a <code>&#123; number: Int &#125;</code> containing the
block number, or a <code>&#123; number_gte: Int &#125;</code> containing the minimum block
number. In the case of <code>number_gte</code>, the query will be executed on the
latest block only if the subgraph has progressed to or past the minimum
block number. Defaults to the latest block when omitted.</p>
</td>
</tr>
<tr>
<td>
subgraphError<br />
<a href="enums#_subgrapherrorpolicy_"><code>_SubgraphErrorPolicy_!</code></a>
</td>
<td>
<p>Set to <code>allow</code> to receive data even if the subgraph has skipped over errors while syncing.</p>
</td>
</tr>
</tbody>
</table>
