import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import DeveloperSupport from "../../../partial/_developer_support.mdx";

# Create Your First Skill

In this tutorial, you will learn how to create your first Moxie Skill for your AI Agent. The Creator Skill demonstrated here is straightforward and enables your AI Agent to provide the most up-to-date summarized information on the Moxie protocol.

## Pre-requisites

Creator Skills are essentially custom Eliza plugins that you can build to enhance your AI Agents.

Before you begin development, please ensure you have all the prerequisites for the Eliza Framework:

- Node.js 23+
- pnpm 9+
- Git for version control
- A code editor (VS Code or VSCodium recommended)
- CUDA Toolkit (optional, for GPU acceleration)
- OpenAI API Key (for OpenAI models)

Once your environment is set up, fork [**the repository**](https://github.com/moxie-protocol/moxie-agent-plugin?tab=readme-ov-file#register-your-skills-to-moxie) and then clone it locally to your machine.

Once you cloned the repository, you can setup your environment with the following scripts:

```sh
cd moxie-agent-plugin
cp .env.example .env
pnpm i && pnpm build
```

In the newly created `.env` file, you can add your OpenAI API key to the `OPENAI_API_KEY` environment variable. Feel fee to provide other relevant API keys if you are using other AI models for your agent.

## Step 1: Define a New Plugin

First, create a separate branch in your forked repository:

```sh
git checkout -b <new-branch>
```

Then, copy the packages/\_examples/plugin directory—which contains templates for new skills—into a new folder under the packages directory:

```sh
cp ./packages/_examples/plugin ./packages/plugin-first-skill
```

Once you created a new folder that will contain the code for your new AI Agent skills, go to `packages/plugin-first-skill/package.json` to update the `name` and `version` of the Skills:

```json
{
  "name": "@moxie-protocol/plugin-first-skill",
  "version": "0.0.1"
  // other fields stay the same
}
```

then, open the `packages/plugin-first-skill/src/index.ts` file to define your plugin instance:

```ts title="packages/plugin-first-skill/src/index.ts"
// all import statements no changes

const samplePlugin: Plugin = {
  name: "my-first-moxie-skill",
  description:
    "This plugin is invoked when the user is asking for the current state of the Moxie protocol.",
  actions: [],
  providers: [],
  evaluators: [],
  services: [],
  clients: [],
};

export default samplePlugin;
```

## Step 2: Create New Provider & Action For The Agent

After defining your plugin, you will create a new Eliza provider and a new action to give your agent the ability to handle protocol-specific data.

Eliza providers and actions are core components of the Eliza framework that help modularize and extend the functionality of your AI Agent. A provider injects dynamic, real-time context into the agent’s interactions, while an action defines how the agent responds to user inputs.

### Step 2.1: Create A New Provider

First, create a provider to pull the Moxie protocol information from the subgraph and integrate that data into the agent’s context. Place this new file under the `src/providers` directory:

```ts title="packages/plugin-first-skill/src/providers/moxieSummaryProvider.ts"
import {
  type Provider,
  type IAgentRuntime,
  type Memory,
  type State,
  elizaLogger,
} from "@moxie-protocol/core";
import { gql, GraphQLClient } from "graphql-request";

const graphQLClient = new GraphQLClient(
  "https://api.studio.thegraph.com/query/23537/moxie_protocol_stats_mainnet/version/latest"
);

const moxieSummaryProvider: Provider = {
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    const query = gql`
      query MyQuery {
        summaries {
          numberOfAuctionOrders
          numberOfBuyOrders
          numberOfSellOrders
          numberOfUsers
          protocolBuyFeePct
          protocolSellFeePct
          subjectBuyFeePct
          subjectSellFeePct
          totalBuyVolume
          totalProtocolFee
          totalProtocolFeeFromAuction
          totalProtocolTokenInvested
          totalReserve
          totalSellVolume
          totalStakedSubjectTokens
          totalSubjectFee
          totalSubjectFeeFromAuction
          totalSubjectTokensIssued
        }
      }
    `;
    // fetch data from Moxie protocol subgraph here
    // to provide context for AI Agent
    const data = await graphQLClient.request(query);

    return JSON.stringify(data);
  },
};

export default moxieSummaryProvider;
```

### Step 2.2: Create A New Action

Next, define an action that tells your agent how to respond when a user requests Moxie protocol information. To achieve this, you will need to fill out the following fields:

```ts
interface Action {
  // Unique identifier for the action
  name: string;
  // Array of alternative names/variations
  similes: string[];
  // Detailed explanation of the action's purpose
  description: string;
  // Function that checks if action is appropriate
  examples: ActionExample[][];
  // Demonstrates proper usage patterns
  handler: Handler;
  // Determines if the action can be executed
  validate: Validator;
  // When true, suppresses the initial response message before processing the action.
  // Useful for actions that generate their own responses (like image generation)
  suppressInitialMessage?: boolean;
}
```

Create a new file in the `src/actions` directory, and define the new action with your chosen `name`, `similes`, and `description`:

```ts title="packages/plugin-first-skill/src/actions/moxieSummaryAction.ts"
import type {
  Action,
  HandlerCallback,
  IAgentRuntime,
  Memory,
  State,
} from "@moxie-protocol/core";

const moxieSummaryAction: Action = {
  name: "MOXIE_SUMMARY",
  similes: [
    "MOXIE_DATA",
    "MOXIE_SUMMARY_DATA",
    "MOXIE_PROTOCOL_DATA",
    "MOXIE_TRADES_DATA",
    "MOXIE_ECONOMY_DATA",
    "MOXIE_ECONOMIC_DATA",
    "MOXIE_STATS_DATA",
  ],
  description:
    "This plugin is used to fetch and display the current state of the Moxie protocol.",
} as Action;

export default moxieSummaryAction;
```

These metadata guide the AI Agent in selecting the appropriate action when a user sends prompts, so be sure to provide a clear and informative `name`, `similes`, and `description`.

Next, for the `validate` field, keep it simple by returning `true` to ensure requests are always validated:

```ts title="packages/plugin-first-skill/src/actions/moxieSummaryAction.ts" {12}
import type {
  Action,
  HandlerCallback,
  IAgentRuntime,
  Memory,
  State,
} from "@moxie-protocol/core";

const moxieSummaryAction: Action = {
  // ... same as above
  validate: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State
  ): Promise<boolean> => {
    // Add validation logic that returns true/false here
    return true;
  },
} as Action;

export default moxieSummaryAction;
```

If you would like to add any gating logic, then you can add additional if-else statements to the `validate` field where `false` is returned if the requests is invalid.

After that, define the `handler` field to retrieve the Moxie protocol data from the Moxie Summary Provider and return this information to the user.

To achieve this, you also need a template that helps the LLM model extract JSON data from the provider in `template.ts`. For this, you can delete all the content in `template.ts` and replace it with the following code:

```ts title="packages/plugin-first-skill/src/template.ts"
const summaryDetailsTemplate = `
Extract the following JSON fields to get all the summary data and return it in JSON format:

{
    "numberOfAuctionOrders": <string>,
    "numberOfBuyOrders": <string>,
    "numberOfSellOrders": <string>,
    "numberOfUsers": <string>,
    "protocolBuyFeePct": <string>,
    "protocolSellFeePct": <string>,
    "subjectBuyFeePct": <string>,
    "subjectSellFeePct": <string>,
    "totalBuyVolume": <string>,
    "totalProtocolFee": <string>,
    "totalProtocolFeeFromAuction": <string>,
    "totalProtocolTokenInvested": <string>,
    "totalReserve": <string>,
    "totalSellVolume": <string>,
    "totalStakedSubjectTokens": <string>,
    "totalSubjectFee": <string>,
    "totalSubjectFeeFromAuction": <string>,
    "totalSubjectTokensIssued": <string>
}

Here are the providers for context:
{{providers}}
`;

export default summaryDetailsTemplate;
```

And use a schema (with the `zod` library) to validate the data. You can simply delete the code in `packages/plugin-first-skill/src/types.ts` and replace it with the code below:

```ts title="packages/plugin-first-skill/src/types.ts"
import { z } from "zod";

const MoxieSummarySchema = z.object({
  numberOfAuctionOrders: z.string().nullable(),
  numberOfBuyOrders: z.string().nullable(),
  numberOfSellOrders: z.string().nullable(),
  numberOfUsers: z.string().nullable(),
  protocolBuyFeePct: z.string().nullable(),
  protocolSellFeePct: z.string().nullable(),
  subjectBuyFeePct: z.string().nullable(),
  subjectSellFeePct: z.string().nullable(),
  totalBuyVolume: z.string().nullable(),
  totalProtocolFee: z.string().nullable(),
  totalProtocolFeeFromAuction: z.string().nullable(),
  totalProtocolTokenInvested: z.string().nullable(),
  totalReserve: z.string().nullable(),
  totalSellVolume: z.string().nullable(),
  totalStakedSubjectTokens: z.string().nullable(),
  totalSubjectFee: z.string().nullable(),
  totalSubjectFeeFromAuction: z.string().nullable(),
  totalSubjectTokensIssued: z.string().nullable(),
});

export default MoxieSummarySchema;
```

and the `handler` field full code should look as following:

```ts title="packages/plugin-first-skill/src/actions/moxieSummaryAction.ts" {14}
import type {
  Action,
  HandlerCallback,
  IAgentRuntime,
  Memory,
  State,
} from "@moxie-protocol/core";
import summaryDetailsTemplate from "../template";
import MoxieSummarySchema from "../types";

const moxieSummaryAction: Action = {
  // ... same as above
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: { [key: string]: unknown },
    callback?: HandlerCallback
  ) => {
    try {
      const state = await runtime.composeState(message);
      const summaryDetails = await generateObject({
        runtime,
        context: composeContext({
          state,
          template: summaryDetailsTemplate,
        }),
        modelClass: ModelClass.LARGE,
        schema: MoxieSummarySchema,
      });
      const {
        numberOfAuctionOrders,
        numberOfBuyOrders,
        numberOfSellOrders,
        numberOfUsers,
        protocolBuyFeePct,
        protocolSellFeePct,
        subjectBuyFeePct,
        subjectSellFeePct,
        totalBuyVolume,
        totalProtocolFee,
        totalProtocolFeeFromAuction,
        totalProtocolTokenInvested,
        totalReserve,
        totalSellVolume,
        totalStakedSubjectTokens,
        totalSubjectFee,
        totalSubjectFeeFromAuction,
        totalSubjectTokensIssued,
      } = (summaryDetails.object as MoxieSummary) ?? {};

      // reply back to the user with the summary data
      callback?.({
        text: `Here's the summary of the current state of the Moxie protocol:
- Number of Auction Orders: ${numberWithCommas(numberOfAuctionOrders)}
- Number of Buy Orders: ${numberWithCommas(numberOfBuyOrders)}
- Number of Sell Orders: ${numberWithCommas(numberOfSellOrders)}
- Number of Users: ${numberWithCommas(numberOfUsers)}
- Protocol Buy Fee (%): ${formatEther(BigInt(protocolBuyFeePct))}%
- Protocol Sell Fee (%): ${formatEther(BigInt(protocolSellFeePct))}%
- Subject Buy Fee (%): ${formatEther(BigInt(subjectBuyFeePct))}%
- Subject Sell Fee (%): ${formatEther(BigInt(subjectSellFeePct))}%
- Total Buy Volume: ${numberWithCommas(
          Math.trunc(Number.parseInt(formatEther(BigInt(totalBuyVolume))))
        )}
- Total Sell Volume: ${numberWithCommas(
          Math.trunc(Number.parseInt(formatEther(BigInt(totalSellVolume))))
        )}
- Total Protocol Fee: ${numberWithCommas(
          Math.trunc(Number.parseInt(formatEther(BigInt(totalProtocolFee))))
        )}
- Total Protocol Fee (Auction): ${numberWithCommas(
          Math.trunc(
            Number.parseInt(formatEther(BigInt(totalProtocolFeeFromAuction)))
          )
        )}
- Total Protocol Token Invested: ${numberWithCommas(
          Math.trunc(
            Number.parseInt(formatEther(BigInt(totalProtocolTokenInvested)))
          )
        )}
- Total Reserve: ${numberWithCommas(
          Math.trunc(Number.parseInt(formatEther(BigInt(totalReserve))))
        )}
- Total Staked Subject Tokens: ${numberWithCommas(
          Math.trunc(
            Number.parseInt(formatEther(BigInt(totalStakedSubjectTokens)))
          )
        )}
- Total Subject Fee: ${numberWithCommas(
          Math.trunc(Number.parseInt(formatEther(BigInt(totalSubjectFee))))
        )}
- Total Subject Fee (Auction): ${numberWithCommas(
          Math.trunc(
            Number.parseInt(formatEther(BigInt(totalSubjectFeeFromAuction)))
          )
        )}
- Total Subject Tokens Issued: ${numberWithCommas(
          Math.trunc(
            Number.parseInt(formatEther(BigInt(totalSubjectTokensIssued)))
          )
        )}`,
      });
      return true;
    } catch (error) {
      callback?.({
        text: `Sorry, there was an error fetching Moxie summary data: ${
          error instanceof Error ? error.message : "Unknown error"
        }`,
      });
      return false;
    }
  },
} as Action;

export default moxieSummaryAction;
```

Lastly, add an `examples` field to your action. By providing a range of prompts, the agent can learn different question patterns and how to respond appropriately:

```ts title="packages/plugin-first-skill/src/actions/moxieSummaryAction.ts" {12}
import type {
  Action,
  HandlerCallback,
  IAgentRuntime,
  Memory,
  State,
} from "@moxie-protocol/core";

const moxieSummaryAction: Action = {
  // ... same as above
  examples: [
    [
      {
        user: "{{user1}}",
        content: {
          text: "What is the current state of the Moxie protocol?",
        },
      },
      {
        user: "{{agentName}}",
        content: {
          text: `
Here's the summary of the current state of the Moxie protocol:
- Number of Auction Orders: 50
- Number of Buy Orders: 300
- Number of Sell Orders: 200
- Number of Users: 100
- Protocol Buy Fee (%): 5
- Protocol Sell Fee (%): 5
- Subject Buy Fee (%): 3
- Subject Sell Fee (%): 3
- Total Buy Volume: 120,000
- Total Sell Volume: 80,000
- Total Protocol Fee: 500
- Total Protocol Fee (Auction): 200
- Total Protocol Token Invested: 1,000
- Total Reserve: 2,000
- Total Staked Subject Tokens: 3,000
- Total Subject Fee: 300
- Total Subject Fee (Auction): 200
- Total Subject Tokens Issued: 1,500
                    `,
          action: "MOXIE_SUMMARY",
        },
      },
    ],
  ],
} as Action;

export default moxieSummaryAction;
```

### Step 2.3: Integrate The Action Into Your Plugin

Finally, integrate the provider and action above into your plugin by importing it and adding it to the actions array:

```ts title="packages/plugin-first-skill/src/index.ts" {8,9}
import { Action } from "@moxie-protocol/core";
import moxieSummaryAction from "../actions/moxieSummaryAction";
import moxieSummaryProvider from "../providers/moxieSummaryProvider";

const samplePlugin: Plugin = {
  name: "my-first-creator-agent-skill",
  description: "My First Moxie Skill",
  actions: [moxieSummaryAction],
  providers: [moxieSummaryProvider],
  evaluators: [],
  services: [],
  clients: [],
};

export default samplePlugin;
```

and add it to your agent instance on line 489 in `agent/src/index.ts`:

```ts {5} title="agent/src/index.ts"
import { Agent } from "@moxie-protocol/core";
import myFirstCreatorAgentSkill from "@moxie-protocol/plugin-first-skill";

const runtime = new AgentRuntime({
  // other parameters
  plugins: [
    // Other plugins (if any)
    myFirstCreatorAgentSkill,
  ],
});
```

Beyond Eliza providers and actions, you can further tailor your Moxie Skill by incorporating custom evaluators or services to introduce advanced features and monetization options.

## Step 3: Test Your Plugin With The Agent

To test your plugin, start the Eliza framework locally by running:

<Tabs>
    <TabItem value="npm" label="npm">

```bash
npm run start --character="characters/moxie.character.json"
```

    </TabItem>
    <TabItem value="yarn" label="yarn">

```bash
yarn start --character="characters/moxie.character.json"
```

    </TabItem>
    <TabItem value="pnpm" label="pnpm">

```bash
pnpm start --character="characters/moxie.character.json"
```

    </TabItem>
    <TabItem value="bun" label="bun">

```bash
bun start --character="characters/moxie.character.json"
```

    </TabItem>

</Tabs>

With the agent running, you can then start a client with a chat interface to test interactions with your AI Agent:

<Tabs>
    <TabItem value="npm" label="npm">

```bash
npm run start:client
```

    </TabItem>
    <TabItem value="yarn" label="yarn">

```bash
yarn start:client
```

    </TabItem>
    <TabItem value="pnpm" label="pnpm">

```bash
pnpm start:client
```

    </TabItem>
    <TabItem value="bun" label="bun">

```bash
bun start:client
```

    </TabItem>

</Tabs>

Try out various of the following prompts to test your newly created AI Agent Skills yourself:

- What is the current state of the Moxie protocol?
- Give me an update on the Moxie protocol.
- What is the latest stats on the Moxie protocol?
- etc.

Congratulations! 🥳🎉 You have successfully created your first Moxie Skill for your AI Agent.

Next, you can proceed to [connect your skills to Moxie](./02-connect-skills-to-moxie.mdx) and offer your skills in the Moxie AI Agent ecosystem.

## More Resources

For adding more advanced features to your AI Agent, you can refer to the following resources to further develop your AI Agent Skills:

- [Eliza Developer Docs](https://elizaos.github.io/eliza/docs/intro/)
- [Best Practices For Eliza Plugin Development](https://elizaos.github.io/eliza/docs/packages/plugins/#best-practices)
- [Autonomous Trading](https://elizaos.github.io/eliza/docs/advanced/autonomous-trading/)
- [Wallet Secrets Management](https://elizaos.github.io/eliza/docs/guides/secrets-management/)

<DeveloperSupport />
